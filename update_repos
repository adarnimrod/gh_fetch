#!/usr/bin/python
# encoding: utf-8

import sys
import os
import argparse
from subprocess import Popen, PIPE

from urllib2 import urlopen
import json

WHITELIST=[]
BLACKLIST=[]

ACCESS_TOKEN_PARAM = '?access_token=%s'
LISTING_FIX_PARAM = '&per_page=150'
GITHUB_API_HOST = 'https://api.github.com'

GIT_CLONE_CMD = 'git clone %s %s'
GIT_CLONE_API_URL = 'https://%s@github.com/%s'
GIT_SHA_CMD = 'git rev-parse --short %s'
GIT_FETCH_CMD = 'git fetch'

USER_DETAILS_PATH = '/users/%s'

class Color:
    GREEN = "\033[1;32m"
    BLUE = "\033[1;34m"
    YELLOW = "\033[1;33m"
    RED = "\033[1;31m"
    END = "\033[0m"

class AttributeDict(dict):
    def __getattr__(self, attr):
        return self[attr]

class RepoUpdater(object):
    def __init__(self, args):
        self.username = args.username
        self.auth_token = args.token
        self.cwd = args.directory if args.directory else os.getcwd()

        self.debug = args.debug
        self.ssh = args.ssh
        self.mirror = args.mirror
        self.exclude_orgs = args.exclude_orgs
        self.include_org_forks = args.include_org_forks
        self.include_public_org_repos = args.include_public_org_repos
        self.exclude_forks = args.exclude_forks
        self.exclude_own = args.exclude_own
        self.include_wikis = args.include_wikis

        if self.debug:
            # We don't want this printed
            del args['token']
            print "Current configuration: "
            for arg in args:
                print arg, ":", self.get_color_str(args[arg], Color.GREEN)

    def update(self):
        if not os.path.isdir(self.cwd):
            os.makedirs(self.cwd)

        print "User:", self.get_color_str(self.username, Color.GREEN)
        user_data = self.get_user_data()

        repos, excluded_repos = self.get_repos(user_data.repos_url, user_data.organizations_url)
        repos = self.filter_repo_names(repos, excluded_repos)
        for repo in repos:
            print self.get_color_str('{:-^60}'.format(repo.name), Color.YELLOW)
            self.update_repo(repo)

    def get_json(self, uri):
        uri += ACCESS_TOKEN_PARAM % self.auth_token + LISTING_FIX_PARAM

        if self.debug:
            print "Trying:", uri

        return json.loads(urlopen(uri).read(), object_hook=AttributeDict)

    def get_user_data(self):
        return self.get_json(GITHUB_API_HOST + USER_DETAILS_PATH % self.username)

    def get_wiki_repos(self, repos):
        wikis = []
        if not self.include_wikis:
            return wikis
        for repo in repos:
            if repo.has_wiki:
                wiki = AttributeDict(repo)
                # Adjust the name and hardcode master as the default branch
                wiki.name += '.wiki'
                wiki.full_name += '.wiki'
                wiki.ssh_url = wiki.ssh_url.rpartition('.git')[0] \
                               + '.wiki.git'
                wiki.default_branch = 'master'
                wiki.description += ' - Wiki'
                wiki.has_wiki = False
                wikis.append(wiki)

        return wikis

    def get_own_repos(self, repos_url):
        repos = self.get_json(repos_url)
        repos += self.get_wiki_repos(repos)
        repo_count = len(repos)

        if self.exclude_forks:
            repos = [repo for repo in repos if not repo.fork]

        return repos, repo_count

    def get_org_repos(self, orgs_url):
        all_orgs_repos = []
        repo_count = 0

        orgs = self.get_json(orgs_url)
        for org in orgs:
            org_repos = self.get_json(org.repos_url)
            org_repos += self.get_wiki_repos(org_repos)
            repo_count += len(org_repos)

            if not self.include_public_org_repos:
                org_repos = [repo for repo in org_repos if repo.private]
            if not self.include_org_forks:
                org_repos = [repo for repo in org_repos if not repo.fork]

            all_orgs_repos += org_repos

        return all_orgs_repos, repo_count

    def get_repos(self, repos_url, orgs_url):
        repos = []
        if self.debug:
            print "Getting repo data from", self.get_color_str(repos_url, Color.GREEN)

        own_repos, repo_count = self.get_own_repos(repos_url)
        if not self.exclude_own:
            repos += own_repos

        org_repos, org_repo_count = self.get_org_repos(orgs_url)
        if not self.exclude_orgs:
            repos += org_repos

        if self.debug:
            print "Available repos:", self.get_color_str(str(len(repos)), Color.GREEN)
            for repo in repos:
                owner = repo.owner.login
                print " -", self.get_color_str(repo.name, Color.YELLOW)
                print " " * 5, repo.description

        excluded_repos = repo_count + org_repo_count - len(repos)
        return repos, excluded_repos

    def filter_repo_names(self, repos, excluded_repos):
        original_repos = len(repos)

        if BLACKLIST:
            repos = [repo for repo in repos if not repo.name in BLACKLIST]

        if WHITELIST:
            repos = [repo for repo in repos if repo.name in WHITELIST]

        filtered_repos = original_repos - len(repos)

        ignored_repos_str = " (" + str(filtered_repos) + " filtered, " + str(excluded_repos) + " excluded)"
        repo_count_str = str(original_repos - filtered_repos) + " / " + str(original_repos)
        print "Fetching repos:", self.get_color_str(repo_count_str + ignored_repos_str, Color.GREEN)

        for repo in repos:
            owner = repo.owner.login
            print " -", Color.YELLOW + repo.name, Color.END
            print " " * 5, repo.description

        return repos

    def try_clone(self, repo_data, target_directory):
        print "Using", target_directory
        if os.path.isdir(target_directory):
            return False

        print "Need to clone", repo_data.name
        if self.mirror:
            clone_opts = '--mirror'
        else:
            clone_opts = '--recurse-submodules'
        if self.ssh:
            clone_url = repo_data.ssh_url
        else:
            clone_url = GIT_CLONE_API_URL % (self.auth_token,
                                             repo_data.full_name)
        self.system_exec(GIT_CLONE_CMD % (clone_opts, clone_url))

        print "Finished cloning"
        return True

    def get_sha_str(self, branch, directory):
        if self.mirror:
            sha_cmd = GIT_SHA_CMD % branch
        else:
            sha_cmd = GIT_SHA_CMD % 'origin/' + branch
        sha = self.system_exec(sha_cmd, directory, False, True)[1]
        return self.get_color_str(sha, Color.GREEN)

    def print_start_sha(self, branch, directory):
        print("- " + self.get_color_str(branch, Color.GREEN) + " @ " \
                + self.get_sha_str(branch, directory) + ' ..'),

    def update_repo(self, repo_data):
        target_directory = os.path.join(self.cwd, repo_data.name)
        if self.mirror:
            target_directory += '.git'

        if self.try_clone(repo_data, target_directory):
            return

        self.print_start_sha(repo_data.default_branch, target_directory)
        self.system_exec(GIT_FETCH_CMD, target_directory, False)
        print self.get_sha_str(repo_data.default_branch, target_directory)

    def system_exec(self, command, directory=None, show_output=True, ignore_error=False):
        if not directory:
            directory = self.cwd

        try:
            process = Popen(command, stdout=PIPE, stderr=PIPE, shell=True, cwd=directory)
            (output, error) = process.communicate()
            output = output.strip()
            error = error.strip()

            if show_output:
                print output
                sys.stdout.flush()

            if process.returncode != 0:
                raise Exception(error)

            return process.returncode, output, error

        except Exception as err:
            if ignore_error:
                return process.returncode, output, error
            else:
                print Color.RED + "Could not execute", command, err, Color.END
                print "Terminating early"
                exit(1)

    @staticmethod
    def get_color_str(text, color):
        return color + str(text) + Color.END

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Retrieve and/or update local copies of GitHub-hosted repos')

    parser.add_argument('username', \
            help='GitHub username that will be used for cloning and fetching')
    parser.add_argument('token', \
            help='GitHub auth token for that username. \
            You can create one at https://github.com/settings/applications')
    parser.add_argument('--version', \
            action='version', \
            version='%(prog)s v0.7')

    parser.add_argument('-d', '--directory', \
            help='Target directory for cloning and fetching')

    parser.add_argument('-s', '--ssh', \
            help='Fetch repositories using ssh', \
            action='store_true')
    parser.add_argument('-m', '--mirror', \
            help='Mirror bare repositories instead of making full checkouts', \
            action='store_true')
    parser.add_argument('-x', '--exclude-own', \
            help='Exclude own repositories in the updates', \
            action='store_true')
    parser.add_argument('--exclude-forks', \
            help='Exclude forked repositories from the updates', \
            action='store_true')
    parser.add_argument('--exclude-orgs', \
            help='Exclude repos that are in user\'s orgs (this does not filter the ones you have)', \
            action='store_true')
    parser.add_argument('--include-org-forks', \
            help='Include forked repos that are in user\'s orgs', \
            action='store_true')
    parser.add_argument('--include-public-org-repos', \
            help='Include public repos that are in user\'s orgs', \
            action='store_true')
    parser.add_argument('--include-wikis', \
            help='Include repository wikis', \
            action='store_true')

    parser.add_argument('--debug', \
            help='Enable debugging output', \
            action='store_true')

    args = AttributeDict(vars(parser.parse_args()))

    RepoUpdater(args).update()
